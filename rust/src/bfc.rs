use crate::lexer::{Lexer, SourcePosition, Token};
use crate::error::BFVMError;

/// This enum represents the instructions generated by the JIT compiler.
#[derive(PartialEq, Clone, Copy, Debug)]
pub enum OpCode {
    AddB(u8),
    SubB(u8),
    AddP(usize),
    SubP(usize),
    Write,
    Read,
    Jmp(usize),
    Jz(usize),
    End
}

/// This struct represents the JIT compiler that compiles the Brainfuck source
/// code.
pub struct Compiler {
    /// The current token.
    token: Token,

    /// The lexical analyzer getting getting the tokens.
    lexer: Lexer,

    /// The current line in the generated instructions so far.
    currln: usize
}

impl Compiler {
    /// Creates an instance of `Compiler` from a filepath.
    /// 
    /// # Parameters
    /// 
    /// - `filepath` - A path to a Brainfuck source file.
    /// 
    /// # Errors
    /// 
    /// - If the source file does not exist.
    /// - If the contents of the source file could not be read.
    pub fn from_source(filepath: &str) -> Result<Self, BFVMError> {
        Ok(Self {
            token: Token::None,
            lexer: Lexer::from_source(filepath)?,
            currln: 0usize
        })
    }

    /// JIT compiles the Brainfuck source contents.
    /// 
    /// # Errors
    /// 
    /// If there were any syntax errors in the source code.
    pub fn compile(&mut self) -> Result<Vec<OpCode>, BFVMError> {
        let mut code: Vec<OpCode> = Vec::<OpCode>::new();

        self.token = self.lexer.next_token();
        self.parse_program(&mut code)?;

        Ok(code)
    }

    /// Parses the whole Brainfuck program.
    /// 
    /// # Parameters
    /// 
    /// - `code` - The generated output code.
    /// 
    /// # Errors
    /// 
    /// If there were any syntax errors in the source code.
    fn parse_program(&mut self, code: &mut Vec<OpCode>) -> Result<(), BFVMError> {
        while self.token != Token::EndOfFile {
            match self.token {
                Token::Plus => self.parse_add_byte(code),
                Token::Minus => self.parse_sub_byte(code),
                Token::ArrowLeft => self.parse_sub_ptr(code),
                Token::ArrowRight => self.parse_add_ptr(code),
                Token::Dot => self.parse_write(code),
                Token::Comma => self.parse_read(code),
                Token::BracketLeft => self.parse_conditional(code)?,
                _ => {
                    let pos: SourcePosition = self.lexer.current_position();
                    return Err(BFVMError::ErrorPos(pos.line, pos.column, format!("unexpected token: {:?}", self.token)))
                }
            }
        }

        code.push(OpCode::End);
        Ok(())
    }

    /// Parses a string of `+` commands.
    /// 
    /// # Paramaters
    /// 
    /// - `code` - The generated output code.
    fn parse_add_byte(&mut self, code: &mut Vec<OpCode>) {
        let mut operand: u8 = 0u8;

        while self.token == Token::Plus {
            operand += 1;
            self.token = self.lexer.next_token();
        }

        code.push(OpCode::AddB(operand));
        self.currln += 1;
    }

    /// Parses a string of `-` commands.
    /// 
    /// # Paramaters
    /// 
    /// - `code` - The generated output code.
    fn parse_sub_byte(&mut self, code: &mut Vec<OpCode>) {
        let mut operand: u8 = 0u8;

        while self.token == Token::Minus {
            operand += 1;
            self.token = self.lexer.next_token();
        }

        code.push(OpCode::SubB(operand));
        self.currln += 1;
    }

    /// Parses a string of `>` commands.
    /// 
    /// # Paramaters
    /// 
    /// - `code` - The generated output code.
    fn parse_add_ptr(&mut self, code: &mut Vec<OpCode>) {
        let mut offset: usize = 0usize;

        while self.token == Token::ArrowRight {
            offset += 1;
            self.token = self.lexer.next_token();
        }

        code.push(OpCode::AddP(offset));
        self.currln += 1;
    }

    /// Parses a string of `<` commands.
    /// 
    /// # Paramaters
    /// 
    /// - `code` - The generated output code.
    fn parse_sub_ptr(&mut self, code: &mut Vec<OpCode>) {
        let mut offset: usize = 0usize;

        while self.token == Token::ArrowLeft {
            offset += 1;
            self.token = self.lexer.next_token();
        }

        code.push(OpCode::SubP(offset));
        self.currln += 1;
    }

    /// Parses the write command.
    /// 
    /// # Paramaters
    /// 
    /// - `code` - The generated output code.
    fn parse_write(&mut self, code: &mut Vec<OpCode>) {
        code.push(OpCode::Write);
        
        self.token = self.lexer.next_token();
        self.currln += 1;
    }

    /// Parses the read command.
    /// 
    /// # Paramaters
    /// 
    /// - `code` - The generated output code.
    fn parse_read(&mut self, code: &mut Vec<OpCode>) {
        code.push(OpCode::Read);

        self.token = self.lexer.next_token();
        self.currln += 1;
    }

    /// Parses any control-flow statements and their bodies.
    /// 
    /// # Paramaters
    /// 
    /// - `code` - The generated output code.
    /// 
    /// # Errors
    /// 
    /// If there were any syntax errors in the source code.
    fn parse_conditional(&mut self, code: &mut Vec<OpCode>) -> Result<(), BFVMError> {
        let mut braces: Vec<(usize, SourcePosition)> = Vec::<(usize, SourcePosition)>::new();

        braces.push((self.currln, self.lexer.current_position()));
        self.currln += 1;

        code.push(OpCode::Jz(0usize));

        self.token = self.lexer.next_token();
        while !braces.is_empty() {
            match self.token {
                Token::Plus => self.parse_add_byte(code),
                Token::Minus => self.parse_sub_byte(code),
                Token::ArrowLeft => self.parse_sub_ptr(code),
                Token::ArrowRight => self.parse_add_ptr(code),
                Token::Dot => self.parse_write(code),
                Token::Comma => self.parse_read(code),
                Token::BracketLeft => {
                    braces.push((self.currln, self.lexer.current_position()));
                    self.currln += 1;

                    code.push(OpCode::Jz(0usize));
                    self.token = self.lexer.next_token();
                },
                Token::BracketRight => {
                    if let Some(open) = braces.pop() {
                        self.currln += 1;
                        code[open.0] = OpCode::Jz(self.currln);
                        code.push(OpCode::Jmp(open.0));

                        self.token = self.lexer.next_token();
                    } else {
                        let pos: SourcePosition = self.lexer.current_position();
                        return Err(BFVMError::ErrorPos(pos.line, pos.column, String::from("stack empty")));
                    }
                },
                Token::EndOfFile => {
                    if let Some(open) = braces.pop() {
                        let pos: SourcePosition = open.1;
                        return Err(BFVMError::ErrorPos(pos.line, pos.column, String::from("no matching ']'")));
                    } else {
                        let pos: SourcePosition = self.lexer.current_position();
                        return Err(BFVMError::ErrorPos(pos.line, pos.column, String::from("stack empty")));
                    }
                },
                _ => panic!("unexpected token: {:?}", self.token) // This suggests that Token::None was found, which should never happen.
            }
        }

        Ok(())
    }
}

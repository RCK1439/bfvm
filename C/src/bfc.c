/**
 * @file   bfc.c
 * @brief  Implementation of the Brainfuck compiler for BFVM.
 * @author Ruan C. Keet
 * @date   03-11-2023
 */

#include "bfc.h"
#include "error.h"
#include "lexer.h"
#include "bstack.h"

/* --- constants ------------------------------------------------------------*/

#define INIT_CODE_SIZE 32UL

/* --- global variables -----------------------------------------------------*/

static token_t token;    /* the current token */
static bytecode_t *code; /* the code generated by the compiler */
static size_t pos;       /* the current pointer into the code */
static size_t size;      /* the current size of the code */

/* --- parser routines ------------------------------------------------------*/

static void parse_program(void);
static void parse_add_byte(void);
static void parse_sub_byte(void);
static void parse_add_ptr(void);
static void parse_sub_ptr(void);
static void parse_write(void);
static void parse_read(void);
static void parse_conditional(void);

/* --- utility functions ----------------------------------------------------*/

/**
 * Ensures that there's enough space in `code` for the next instruction.
 */
static void ensure_space(void);

/* --- bfc interface --------------------------------------------------------*/

bytecode_t *compile(const char *filepath)
{
    FILE *src;
    
    pos = 0;
    size = INIT_CODE_SIZE;
    code = (bytecode_t*)emalloc(sizeof(bytecode_t) * size);

    if (filepath) {
        setprogname(filepath);
        if ((src = fopen(filepath, "r")) == NULL) {
            log_err("could not open file: %s", filepath);
        }
    } else {
        log_info("enter commands:");
        src = stdin;
    }

    init_lexer(src);
    parse_program();

    if (filepath) {
        fclose(src);
        freeprogname();
    }

    return code;
}

/* --- parser routines ------------------------------------------------------*/

static void parse_program(void)
{
    next_token(&token);
    while (token != TOK_EOF) {
        switch (token) {
            case TOK_ADD: parse_add_byte(); break;
            case TOK_SUB: parse_sub_byte(); break;
            case TOK_ARROW_RIGHT: parse_add_ptr(); break;
            case TOK_ARROW_LEFT: parse_sub_ptr(); break;
            case TOK_DOT: parse_write(); break;
            case TOK_COMMA: parse_read(); break;
            case TOK_BRACE_LEFT: parse_conditional(); break;
            default: log_err("unknown command: %c", (char)token);
        }
    }

    ensure_space();
    code[pos].op = BFVM_END;
}

static void parse_add_byte(void)
{
    ensure_space();

    code[pos].op = BFVM_ADDB;
    code[pos].operands.bval = 0;
    
    while (token == TOK_ADD) {
        code[pos].operands.bval++;
        next_token(&token);
    }

    pos++;
}

static void parse_sub_byte(void)
{
    ensure_space();

    code[pos].op = BFVM_SUBB;
    code[pos].operands.bval = 0;

    while (token == TOK_SUB) {
        code[pos].operands.bval++;
        next_token(&token);
    }

    pos++;
}

static void parse_add_ptr(void)
{
    ensure_space();
    
    code[pos].op = BFVM_ADDP;
    code[pos].operands.dval = 0;

    while (token == TOK_ARROW_RIGHT) {
        code[pos].operands.dval++;
        next_token(&token);
    }

    pos++;
}

static void parse_sub_ptr(void)
{
    ensure_space();

    code[pos].op = BFVM_SUBP;
    code[pos].operands.dval = 0;

    while (token == TOK_ARROW_LEFT) {
        code[pos].operands.dval++;
        next_token(&token);
    }

    pos++;
}

static void parse_write(void)
{
    ensure_space();

    code[pos++].op = BFVM_WRITE;
    next_token(&token);
}

static void parse_read(void)
{
    ensure_space();

    code[pos++].op = BFVM_READ;
    next_token(&token);
}

static void parse_conditional(void)
{
    brace_t brace;
    size_t open;

    init_stack();
    
    brace.asm_pos = pos;
    brace.src_pos = position;
    push(brace);

    ensure_space();
    code[pos++].op = BFVM_JZ;

    next_token(&token);
    while (!empty()) {
        if (token == TOK_EOF) {
            pop(&brace);
            position = brace.src_pos;

            log_errpos("no matching ']'");
        } else switch (token) {
            case TOK_ADD: parse_add_byte(); break;
            case TOK_SUB: parse_sub_byte(); break;
            case TOK_ARROW_RIGHT: parse_add_ptr(); break;
            case TOK_ARROW_LEFT: parse_sub_ptr(); break;
            case TOK_DOT: parse_write(); break;
            case TOK_COMMA: parse_read(); break;
            case TOK_BRACE_LEFT: {
                brace.asm_pos = pos;
                brace.src_pos = position;
                push(brace);

                ensure_space();
                code[pos++].op = BFVM_JZ;

                next_token(&token);
            } break;
            case TOK_BRACE_RIGHT: { 
                pop(&brace);
                open = brace.asm_pos;

                code[open].operands.line = pos + 1;

                ensure_space();
                code[pos].op = BFVM_JMP;
                code[pos++].operands.line = open;

                next_token(&token);
            } break;
            default:
                log_err("unknown command: %c", (char)token);
        }
    }
    
    free_stack();
}

static void ensure_space(void)
{
    if (pos < size) {
        return;
    }

    size = size + (size / 2);
    code = (bytecode_t*)erealloc(code, sizeof(bytecode_t) * size);
}

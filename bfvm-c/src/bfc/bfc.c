/**
 * @file   bfc.c
 * @brief  Implementation of the Brainfuck compiler for BFVM.
 * @author Ruan C. Keet
 * @date   03-11-2023
 */

#include "bfc.h"
#include "error.h"
#include "lexer.h"

/* --- constants ----------------------------------------------------------- */

#define INIT_CODE_SIZE 32UL

/* --- macros -------------------------------------------------------------- */

#define PARSE_CHAIN(TOKEN, OP, OFFSET)\
ensure_space();\
code[pos].op = OP;\
OFFSET = 0;\
while (token == TOKEN) {\
    OFFSET++;\
    next_token(&token);\
}\
pos++\

/* --- global variables ---------------------------------------------------- */

static token_t token;    /* the current token */
static bytecode_t *code; /* the code generated by the compiler */
static size_t pos;       /* the current pointer into the code */
static size_t size;      /* the current size of the code */

/* --- parser routines ----------------------------------------------------- */

static void parse_program(void);
static void parse_add_byte(void);
static void parse_sub_byte(void);
static void parse_add_ptr(void);
static void parse_sub_ptr(void);
static void parse_write(void);
static void parse_read(void);
static void parse_conditional(void);

/* --- utility functions --------------------------------------------------- */

/**
 * Ensures that there's enough space in `code` for the next instruction.
 */
static void ensure_space(void);

/* --- bfc interface ------------------------------------------------------- */

bytecode_t *compile(const char *filepath) {
    FILE *src;
    
    pos = 0;
    size = INIT_CODE_SIZE;
    code = (bytecode_t*)emalloc(sizeof(bytecode_t) * size);

    if (filepath) {
        setprogname(filepath);
        if ((src = fopen(filepath, "r")) == NULL) {
            log_err("could not open file: %s", filepath);
        }
    } else {
        log_info("enter commands:");
        src = stdin;
    }

    init_lexer(src);
    parse_program();

    if (filepath) {
        fclose(src);
        freeprogname();
    }

    return code;
}

/* --- parser routines ------------------------------------------------------*/

static void parse_program(void) {
    next_token(&token);
    while (token != TOK_EOF) {
        switch (token) {
            case TOK_ADD: parse_add_byte(); break;
            case TOK_SUB: parse_sub_byte(); break;
            case TOK_ARROW_RIGHT: parse_add_ptr(); break;
            case TOK_ARROW_LEFT: parse_sub_ptr(); break;
            case TOK_DOT: parse_write(); break;
            case TOK_COMMA: parse_read(); break;
            case TOK_BRACE_LEFT: parse_conditional(); break;
            default: log_err("unknown command: %c", (char)token);
        }
    }

    ensure_space();
    code[pos].op = BFVM_END;
}

static void parse_add_byte(void) {
    PARSE_CHAIN(TOK_ADD, BFVM_ADDB, code[pos].operands.byte_offset);
}

static void parse_sub_byte(void) {
    PARSE_CHAIN(TOK_SUB, BFVM_SUBB, code[pos].operands.byte_offset);
}

static void parse_add_ptr(void) {
    PARSE_CHAIN(TOK_ARROW_RIGHT, BFVM_ADDP, code[pos].operands.data_offset);
}

static void parse_sub_ptr(void) {
    PARSE_CHAIN(TOK_ARROW_LEFT, BFVM_SUBP, code[pos].operands.data_offset);
}

static void parse_write(void) {
    ensure_space();

    code[pos++].op = BFVM_WRITE;
    next_token(&token);
}

static void parse_read(void) {
    ensure_space();

    code[pos++].op = BFVM_READ;
    next_token(&token);
}

static void parse_conditional(void) {
    const size_t open_pos = pos;
    const sourcepos_t open_src_position = position;

    ensure_space();
    code[pos++].op = BFVM_JZ;

    next_token(&token);
    while (token != TOK_BRACE_RIGHT) {
        switch (token) {
            case TOK_ADD: parse_add_byte(); break;
            case TOK_SUB: parse_sub_byte(); break;
            case TOK_ARROW_RIGHT: parse_add_ptr(); break;
            case TOK_ARROW_LEFT: parse_sub_ptr(); break;
            case TOK_DOT: parse_write(); break;
            case TOK_COMMA: parse_read(); break;
            case TOK_BRACE_LEFT: parse_conditional(); break;
            case TOK_EOF:
                position = open_src_position;
                log_err("no matching ']'");
                break;
            default: log_err("unknown command: %c", (char)token);
        }
    }

    next_token(&token);
    code[open_pos].operands.instr_line = pos + 1;

    ensure_space();
    code[pos].op = BFVM_JMP;
    code[pos++].operands.instr_line = open_pos;
}

static void ensure_space(void) {
    if (pos < size) {
        return;
    }

    size = size + (size / 2);
    code = (bytecode_t *)erealloc(code, sizeof(bytecode_t) * size);
}
